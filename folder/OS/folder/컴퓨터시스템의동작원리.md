# 컴퓨터 시스템의 동작 원리

- [컴퓨터 시스템의 동작 원리](#컴퓨터-시스템의-동작-원리)
  - [1. 컴퓨터 시스템의 구조](#1-컴퓨터-시스템의-구조)
  - [2. CPU와 I/O 연산](#2-cpu와-io-연산)
  - [3. 인터럽트의 일반적 기능](#3-인터럽트의-일반적-기능)
  - [4. 인터럽트 핸들링](#4-인터럽트-핸들링)
  - [5. 입출력 구조](#5-입출력-구조)
  - [6. DMA(Direct Memory Access)](#6-dmadirect-memory-access)
  - [7. 저장 장치의 구조](#7-저장-장치의-구조)
  - [8. 저장 장치의 계층 구조](#8-저장-장치의-계층-구조)
  - [9. 하드웨어의 보안](#9-하드웨어의-보안)
  - [10. 메모리 보안](#10-메모리-보안)
  - [11. CPU 보호](#11-cpu-보호)
  - [12. 시스템 콜을 이용한 입출력 수행](#12-시스템-콜을-이용한-입출력-수행)




<br/><br/>

## 1. 컴퓨터 시스템의 구조


컴퓨터 시스템의 구조는 컴퓨터 내부 장치인 CPU, 메모리와 컴퓨터 외부 장치인 디스크，키보드，마우스，모니터，네트워크 장치 등으로 구 분된다. 컴퓨터 입장에서 보면 컴퓨터의 업무 처리 방식은 컴퓨터 외 V 장치에서 컴퓨터 내부로 데이터를 읽어와서 각종 연산을수행한후 그 결과를 컴퓨터 외부 장치로 다시 내어 보내는 방식으로 진행된다. 이 때 컴퓨터 내부로 데이터가 들어오는 것을 입력(input)이라 하고，컴 퓨터 외부 장치로 데이터가 나가는 것을 출력(output)이라고 한다. 예 를 들어 키보드로부터 입력을 받아서 컴퓨터가 어떤 연산을 한 후 그 결과를 모니터에 출력하는 경우를 대표적인 입출력(I/O: input-output) 이라고 말할 수 있다. 따라서，컴퓨터 외부 장치를 입출력 장치라고도 부른다. 디스크도 컴퓨터 외부 장치이므로 디스크에서 내용을 읽어 컴퓨터 내부에서 어떤 연산을 한 후 디스크에 데이터를 저장했다면 컴퓨 터 입장에서는 입력과 출력이 일어난 것이다.
컴퓨터 내의 각 하드웨어 장치에는 컨트롤러(controller: 제어기)라 는 것이 붙어 있다. 컨트롤러는 일종의 작은 CPU로서，컴퓨터 전체에 CPU라는 중앙 처리 장치가 있듯이 컨트롤러는 각 하드웨어 장치마다 존재하면서 이들을 제어하는 작은 CPU라고 할 수 있다. 예를 들면 메 모리를 제어하는 컨트롤러는 메모리 컨트롤러이고，디스크를 제어하 는 컨트롤러는 디스크 컨트롤러이다.
우리가 생각하는 운영 체제는 여러 프로그램이 동시에 수행되는 시 스템을 위한 운영 체제이다. 이 때 프로그램이 수행되려면 그 고무그 램이 메모리에 올라가 있어야 한다. 운영 체제는 컴퓨터가 부팅되었을 때부터 항상 수행되면서 각종 자원들을 관리해야 하므로 항상 메모리 에 올라가 있다. 이 때，운영 체제의 코드가 매우 크기 때문에 모든 코 드를 다 메모리에 상주시키면 메모리의 낭비가 심하게 된다. 따라서， 운영 체제 중 항상 메모리에 올라가 있는 부분은 전체 운영 체제 중 일 부분에 해당하는데，이 부분을 커널(kernel)이라고 부른다.

<br/><br/>

## 2. CPU와 I/O 연산

<br/><p align = "center">
<img src = "img\0002.png">
</p>

컴퓨터 에서 연산을 한다는 것은 CPU가 무언가 일을 한다는 뜻이다. 입출력 장치들의 I/O 연산은 I/O 컨트롤러가 담당하고，컴퓨터 내에서 수행되는 연산은 메인 CPU가 담당하게 된다. 이 때 입출력 장치와 메인 CPU는 동시 수행이 가능하다. 예를 들어 B라는 프로그램이 현재 CPU 를 할당받고 프로그램 코드를 수행중이고，A라는 프로그램은 하드 디 스크에서 어떠한 정보를 읽어오는 작업을 수행하는 상황을 생각해 볼 수 있다. 이 러한 경우 두 가지 일이 다른 곳에서 발생하므로 동시에 수 행되는 것이 가능하다. 한편，각 장치마다 이를 제어하기 위해 설치된 장치 컨트롤러에는 장치로부터 들어오고 나가는 데이터를 임시로 저장 하기 위한 작은 메모리를 가지고 있다. 이를 로컬 버퍼(local buffer)라고 부른다.
디스크나 키보드 등에서 데이터를 읽어오는 경우，우선 로컬 버퍼에 데이터가 임시로 저장된 후 메모리에 전달된다. 이 때，장치에서 로컬 버퍼로 읽어오는 일은 컨트롤러가 담당한다. 예를 들어 프로그램 B가 수행중에，디스크에서 데이터를 읽어오라는 명령을 내리면 디스크 컨 트롤러가 물리적인 디스크에서 내용을 읽어 이를 로컬 버퍼에 저장한 다. 원하는 데이터를 로컬 버퍼로 다 읽어오고 나면，B는 자신이 필요한 데이터를 다 읽어왔으므로 메인 CPU에서 다음 일을 수행할 수 있 다. 데이터를 모두 가지고 왔는지 확인하는 작업은 메인 CPU가 일일이 체크하는 것이 아니라 장치에 있는 컨트롤러가 인터럽트를 발생시켜 cpiH 게 보고하게 된다. 이 때 인터럽트란 컨트롤러들이 cpu의 서비 스가 필요할 때 이를 통보하는 방법을 말한다. 기본적으로 CPU는 매 시점 메모리에서 명령을 하나씩 읽어와서 수행한다. 이 때，CPU 옆에 는 인터 럽트 라인(inteirupt line)이 있어서，CPU가 자신의 작업을 하던 중간에 인터 럽트 라인에 신호가 들어오면 하던 일을 멈추고，인터 럽트 와 관련된 일을 처리한다. 좀더 정확히 설명하면 CPU는 명령 하나를 수행할 때마다 인터럽트가 발생했는지를 체크하게 된다. 인터럽트가 발생했으면 다음 명령을 수행하기 전에 인터 럽트 처 리를 하게 되고 그 렇지 않으면 다음 명령을 계속 수행하게 되는 것이다. 인터 럽트는 키 보드 입력 혹은 디스크에서 데이터를 다 읽어왔다는 등의 이벤트를
CPU에게 알려 줄 필요가 있는 경우 컨트롤러가 발생시키는 것이다.


<br/><br/>

## 3. 인터럽트의 일반적 기능
앞의 예에서 프로그램이 요청한 데이터를 디스크 컨트롤러가 로컬 버퍼로 다 읽어온 후 인터럽트를 발생시키면 CPU는 인터 럽트가 들어 옴을 인지하고 인터 럽트 관련 업무를 수행하게 된다. 운영 체제 커널 에는 인터 럽트가 들어왔을 때 해야 할 일을 미리 다 프로그래밍해서 보 관하고 있다. 운영 체제는 각종 하드웨어，소프트웨어 자원 관리뿐 아 니라 사용자 프로그램에게 필요한 서비스도 제공한다. 이와 같이 운영 체제가 해야 할 일들을 운영 체제의 개발자가 미리 프로그래밍을 해서 커널 내에 포함시켜 두게 된다. 그 중 한 가지가 인터럽트 처리 루틴이 다. 운영 체제 커널 내에 있는 인터럽트 처리 루틴은 다양한 인터럽트 에 대해 각각 처리해야 할 업무들을 정의하고 있다. 앞의 예와 같이 디 스크 컨트롤러가 인터 럽트를 발생시키면 CPU는 하던 일을 잠시 멈추 고 이 인터럽트가 발생했을 때 수행해야 할 코드 영역으로 가서 정의된 일을수행하게 된다. 이 때 수행하는 구체적인 일들은 다음과같다.
먼저 로컬 버퍼에 있는 내용을 프로그램 B가 사용할 수 있도록 메모 리로 전달하고，이제 B가 CPU를 할당받을 경우 다음 명령(instruction) 을 수행할 수 있음을 표시해 둔다.
한편 인터 럽트에는 하드웨 어 인터 럽트와 소프트웨 어 인터 럽트가 있 다. CPU의 서비스가 필요한 경우，CPU 옆에 있는 인터럽트 라인에 신 호를 보내어서 인터 럽트가 발생했음을 알려 주는 방식은 둘 다 동일하 다. 다만，하드웨어 인터 럽트는 컨트롤러 등 하드웨어 장치가 CPU의 인터 럽트 라인을 세팅하는 반면 소프트웨어 인터 럽트는 소프트웨어가 그 일을 수행한다는 차이점이 있다. 하드웨어 인터럽트이든 소프트웨 어 인터 럽트이든 간에 일단 인터 럽트가 발생하면 CPU는 하던 일을 멈 추고 인터 럽트를 처 리하기 위한 루틴(운영 체제 커널 내부 코드)에 들 어가서 정의된 일을 찾게 된다. 운영 체제는 할 일을 쉽게 찾아가기 위 해 인터 럽트 벡터 (intempt vector)를 가지고 있다. 인터 럽트 벡터 란 인 터 럽트 종류마다 번호를 정해서，번호에 따라 처리해야 할 코드가 위치 한 부분을 포인터로 가리키고 있는 자료 구조를 말한다. 실제 처리해 야 할 내용은 인터 럽트 서비스 루틴(intemipt service routine)이라는 다 른 곳에 정의된다.

인터럽트 서비스 루틴을 통해 해당하는 인터 럽트 처리를 완료하고 나면 원래 수행하던 작업으로 돌아가 정지되었던 일을 계속해서 수행 하게 된다. 인터럽트 처리 후에 되돌아갈 위치를 알아야 하므로 인터 럽트 처리 전에 수행중이던 작업이 무엇이었는지 반드시 저장해 두어 야 한다. 이러한 정보를 저장하기 위한 장소를 운영 체제는 별도로 가 지고 있다.
통상적으로 프로그램은 여러 개의 함수로 구성된다. 프로그램의 메 모리 주소를 조사해 보면 크게 코드(code), 데이터(data), 스택(stock) 등의 영역으로나뉜다.
스택이란 실행중인 함수에서 다른 함수를 호출한 경우 호출된 함수 의 종료 후 원래 함수의 실행중이던 위치로 돌아가기 위해 복귀 주소를 저장하는 영역이다. 즉 우리가 만든 프로그램이 메인 함수에서 실행되 다가 다른 함수를 호출하면 다음 명령(instruction)을 수행하는 메모리 의 위치가 바뀌게 된다. 이는 호출된 함수의 영역으로 점프(jump)해서 실행하기 때문이다. 호출된 함수를 모두 수행하고나면 원래 함수의 수 행되던 위치로 돌아가게 되는데 이 때 스택에 저장되어 있는 복귀 주소 를사용하게 된다.
데이터 영역은 전역 변수 등 프로그램이 사용하는 각종 데이터가 저 장되는 공간이다. 데이터 영역에 저장되는 전역 변수들은 동일한 프로 그램 내의 모든 함수들이 공유해 사용할 수 있게 된다.
마지막으로 코드 부분은 프로그래머가 작성한 코드가 기계어 명령 (machine instruction) 형태로 저장되는 영역이다. CPU는 매 시점 코드 부분에 있는 명령을 하나씩 읽어와서 수행하게 된다.

<br/><br/>

## 4. 인터럽트 핸들링
<br/><p align = "center">
<img src = "img\20211104_071535064_22.jpg">
</p>

인터 럽트 핸들링(intempt handling)이란 인터럽트가 발생한 경우에 처리해야 할 일의 절차를 의미한다. 인터럽트도 앞서 설명한 함수 호 출과 유사한 메커니즘으로 처리하게 된다. 프로그램 A가 수행되고 있 을 때 인터 럽트가 발생하면 A의 현재 상태를 저장하게 된다. 현재 상태 란 현재 CPU가 수행중이던 메모리 주소를 포함해 몇 가지 부가적인 정 보들을 의미한다. CPU에명령이 수행될 때에는 CPU 내부에 있는 임 시 기억 장치인 레지스터(register)에 데이터를 읽어오거나 쓰면서 작업 을 수행하게 되는데，이 때 인터 럽트가 발생해 새로운 명령을 수행하면 기존의 레지스터 값들이 지워지게 되므로 레지스터 값 등 CPU 내의 하 드웨어 상태를 저장해 두어야 한다. 이것을 모두 저장한 후에야 인터 럽트 처 리가 이루어질 수 있는 것이다.
운영 체제 커널 영역에는 현재 시스템 내에서 수행되는 프로그램들 을 관리하기 위한 자료 구조인 프로세스 제어 블록(PCB: Process Control BlockX 두고 있다. 그 자료 구조 중 일부분은 인터 럽트가 발 생했을 때 프로그램의 어느 부분이 수행되던 중이었는지를 저장하기 위한 자료 구조로 사용된다. 이 부분에 저장되는 내용으로는 현재 수 행중이던 메모리 주소와 레지스터 값，그리고 하드웨어 상태 등이 있 다. 이러한 정보가 저장되었다가 인터럽트 수행이 끝나면 저장된 값을 CPU 상에 다시 복원해 인터럽트당하기 직전의 명령을 계속 수행할 수 있게 되는 것이다.
프로그램 내부의 함수 호출시 그 복원 지점에 대한 정보는 각 프로 그램의 주소 공간 중 스택 부분에 저장된다. 한편，인터 럽트 처리 루틴은 운영 체제 커널 프로그램 중 일부이고 커널 역시 함수 구조로 이루 어져 있으므로 인터 럽트 처리 코드가 수행되는 도중에도 함수 호출이 이루어질 수 있어 스택의 이용이 필요하다. 인터 럽트의 처리는 커널의 코드를 수행하는 것이므로 인터럽트 처리 중 발생하는 함수 호출시에 는운영 체제 커널의 주소 공간중스택 영역을사용한다.
한편 현재 수행중인 프로그램의 수가 n개라고 할 때 커널 스택은 현 재 수행중인 프로그램의 개수인 n만큼 독립적인 공간을 둔다. 이는 비 록 커널이 하나의 프로그램이지만 여러 사용자 프로그램이 수행되는 도중에 인터럽트 등을 통해 커널 코드가 수행될 수 있으므로 커널은 일 종의 공유 코드라고 볼 수 있기 때문이다. 즉，인터 럽트 처 리 루틴으로 넘어와서 함수 호출이 이루어질 경우에는 각 프로세스별로 독자적인 커널 스택을 사용하게 된다. 다시 말하면 직전에 인터 럽트당한 프로세 스의 독자적인 커널 스택에 함수 호출 및 리턴과 관련된 정보를 저장하 게 되는 것이다. 프로그램 A가 수행중에 인터 럽트가 발생하면 현재까 지 수행된 지점을 프로세스 제어 블록에 저장하고，인터 럽트 처 리 루틴 으로 와서 커널 코드를 수행하게 되며，이 때 이루어지는 함수 호출은 프로세스 A의 커널 스택을 사용하게 된다. 인터 럽트 처리가 끝마쳐진 후에는 프로세스 제어 블록에 저장된 주소로 되돌아가서 중지된 작업 의 나머지 부분을 수행하게 된다.
그렇다면 인터 럽트 처 리중에 또 다른 인터 럽트가 발생하는 경우에 어떻게 처리되는가에 대해 알아보도록 하자. 원칙적으로는 인터럽트 처리중에 또 다른 인터 럽트가 발생하는 것을 허용하지 않는다. 그 이유는 인터럽트 처리중에 다른 인터럽트를 처리하게 되면 데이터의 일 관성이 유지되지 않는 경우가 발생할 수 있기 때문이다. 인터럽트를 서리하는 중 운영 체제 커널에 정의된 데이터를 변경하고 있는데 다른 인터럽트가 발생해 앞선 인터럽트에서 변경중이던 데이터를 또다시 변경하게 되면 두 인터럽트에 의해 데이터가 원래 의도하지 않았던 결 과값으로 변경될 수 있기 때문이다. 그렇지만 경우에 따라 예외가 존 재할 필요성이 있다. 예를 들어 인터 럽트가 발생해 현재 인터 럽트 처 리 루틴을 수행하고 있지만 그것보다 더 시급하거나 CPU를 당장 사용 해야 하는 일이 발생할 수 있기 때문이다.
다시 말하면，인터 럽트마다 중요도가 다르기 때문에 상대적으로 낮 온 중요도를 가진 인터 럽트 작업 수행중에 중요도가 더 높은 인터 럽트 가 발생하는 것을 허락할 필요가 있다. 이와 같이 현재 처리중인 인터 럽트보다 더 높은 우선순위의 인터럽트가 발생한다면 현재 처리중이 던 인터 럽트 코드의 수행 지점을 커널 스택에 저장하고 우선순위가 높 온 인터럽트를 처리하게 된다. 인터럽트 처리가 마쳐지면 커널 스택에 저장된 주소로 복귀해 이전에 수행하던 인터럽트 처리 코드를 마저 수행하게 된다.
실질적인 예를 들어 설명하도록 하겠다. A라는 프로그램이 수행되 다가 인터 럽트가 발생하면 인터 럽트 처 리 루틴 내에서의 함수 호출 및 리턴 정보는 A의 커널 스택에 저장하게 된다. 요청된 인터럽트에 대한 처 리를 수행하던 중에 또 다른 인터 럽트가 발생하면，이 인터 럽트 처 리 중 발생하는 함수 호출 및 리턴과관련된 정보를 A의 커널 스택 에 또다 시 저장하게 된다. 스택에서 함수를 호출한 후 호출된 함수가 또 다른 함수를 호출할 때와 마찬가지로 중요도가 높은 인터 럽트를 먼저 처 리 하고난 후，CPU를 점 령당한 이전의 인터 럽트로 돌아가서 하던 작업을 처리하게 된다.
다음으로 소프트웨어 인터 럽트에 관해 알아보도록 하자. 통상적으 로 인터 럽트라고 하면 하드웨어 인터 럽트를 의미하고，소프트웨어 인 터 럽트는 트랩(trap)이라는 용어로 주로 불린다. 소프트웨어 인터 럽트 의 예로는 예외 상황(exception), 시스템 콜(system call) 등이 있다. 예 외 상황이란 프로세스가 0으로 나누는 연산 등 불가능한 작업을 시도 하거나，자신의 메모리 영역 바깥을 접근하려는 시도를 할 때 이에 대 한 처리를 위해 발생시키는 인터럽트를 말한다. 소프트웨어 인터럽트 는 하드웨어 인터럽트처럼 컨트롤러가 발생시키는 인터럽트가 아니라 프로그램 수행 도중 직접 CPU에 인터 럽트 라인을 세팅하여 발생시키 게 된다. 소프트웨어 인터 럽트가 발생하면 현재까지의 수행 지점을 저 장하고，인터 럽트 처 리 루틴으로 가서 인터 럽트 발생과 관련한 작업을 수행하고나서，다시 인터럽트당한 지점으로 돌아와 프로그램을 계속 실행하게 된다. 넓은 의미로는 하드웨어 인터 럽트 및 소프트웨어 인터 럽트를 합쳐 인터 럽트라고 말하기도 한다.

오늘날의 컴퓨터에서 운영 체제는 인터럽트 발생시에만 수행된다. 이는 시스템 이 부팅 후 정상 상태에 머무르게 되면 CPU가 항상 사용자 프로그램에 의해 사용되며 운영 체제는 단지 인터럽트 발생시에만 잠 깐 CPU의 제어권을 획득할 수 있기 때문이다. 인터 럽트가 발생하지 않 으면 원래 수행중인 사용자 프로세스가 원하는 만큼 CPU를 계속 점유 하고 있게 된다. 즉，인터 럽트가 발생할 때에만 운영 체제 코드 부분으 로 CPU가 이양되어 인터럽트 처리를 수행하게 된다. 결론적으로 운영 체제가 직접 CPU를 점유하는 경우는 인터 럽트에 의하지 않고는 발생 하지 않는다. 그럼에도 불구하고 운영 체제는 컴퓨터 시스템 내의 모 든 하드웨어 및 소프트웨어 자원을 체계적이고 효율적으로 관리할 수 있다.
이제까지 하드웨어 인터럽트 및 소프트웨어 인터럽트의 정의와 핸 들링에 대해 살펴보았다. 하드웨어 인터럽트란 각종 하드웨어 장치들 이 CPU에게 서비스를 받아야 하는 경우에 발생시키게 되며，이는 인터 럽트 라인을 통해 CPU에게 전달된다. 소프트웨어 인터 럽트란 트랩이 라고도 하며 프로그램이 수행되다가 접근해서는 안 되는 메모리 영역 을 침범하려는 경우，0으로 나누는 연산 등을 시도한 경우 등 예외 상 황이나 시스템 콜 시에 발생하며 이 때 소프트웨어적으로 발생되는 인 터 럽트를 의미한다. 즉 소프트웨어 인터 럽트는 프로그램이 잘못된 연 산을 수행할 경우 그것에 대해 적절한 처 리를 위해 사용되는 예외 상황 처리와 프로그램이 자신이 작성하지 않은 코드를 운영 체제로부터 서 비스받기 위해 발생시키는 시스템 콜로 나누어 볼 수 있다. 프로그래 밍을 처음 시작하는 사람들이 가장 많이 접하는 것이 printf( ) 함수이 다. 우리는 이 함수를 사용해 화면에 원하는 내용을 출력할 수 있지만

실제 printf() 함수의 내용은 직접 작성하지 않는다. 이것은 printf( )의 내용을 이미 라이브러리 함수로 누군가가 작성해 두었고，이 라이브러 리 함수가 궁극적으로는 운영 체제 내에 정의된 write()라는 시스템 콜 을 호출하기 때문이다. 일반적인 함수 호출과 시스템 콜을 비교해서 설명하면，함수 호출(function call)이란 자신이 작성한 함수 또는 라이 브러리에 정의된 함수를 호출하는 것을 말하고，시스템 콜이란 운영 체 제에 정의된 함수를 호출하는 것을 말한다. 이 때 시스템 콜은 일종의 인터럽트 메커니즘으로 동작하게 된다. 화면에 정보를 출력하는 printf() 함수를 호출하면 라이브러 리 함수인 printf()는 일종의 인터 럽 트 메커니즘인 write( ) 시스템 콜을 통해 커널에 입출력 명령을 대신 수행하도록 요청하게 된다. 그러면 운영 체제는 해당하는 인터 럽트를 처 리하기 위한 루틴을 찾고 화면에 출력하라는 요청 에 따라 정보를 화 면에 출력하게 되는 것이다.


<br/><br/>

## 5. 입출력 구조
<br/><p align = "center">
<img src = "img\20211104_071535064_16.jpg">
</p>
<br/><p align = "center">
<img src = "img\20211104_071535064_13.jpg">
</p>

입출력(I/O)이란 컴퓨터 시스템이 컴퓨터 외부의 주변 장치들과 데 이터를 주고받는 것을 말한다. 입출력 방식에는 동기식 입출력과 비동 기식 입출력이 있다. 동기식 입출력(synchronous I/O)은 입출력 요청 후 입출력 작업이 완료된 후에야 CPU의 제어권이 그 프로그램에게 다 시 넘어갈 수 있는 방식을 말한다. 예를 들어 프로그램이 디스크에서 어떠한 정보를 읽어오라는 요청을 했다고 할 때 디스크 입출력이 완료 되기까지는 어느 정도의 시간이 걸리게 된다. 이 때，동기식 입출력은


입출력이 진행되는 동안 그 프로그램의 다음 명령을 수행하지 않고 기다리게 된다. 그러다가 입출력이 완료되어 인터럽트를 통해 그 사실이 전달된 후에야 CPU의 제어권이 그 프로그램에게 넘어가서 다음 명령을 수행할 수 있게 된다. 따라서, 동기식 입출력에서는 입출력 연산이 끝날 때까지 CPU는 아무 일을 수행할 수 없다. 한편，CPU의 명 령 수행 속도는 빠른 반면 외부 장치에서 데이터를 읽어오는 등의 입출력 연산 은 상대 적으로 속도가 느리다. 그럼에도 불구하고 입출력이 완료될 때 까지 기다렸다가 사용자 프로그램에게 CPU의 제어권을 넘기는 방식
은 입출력이 완료될 때까지 CPU가 아무 일도 하지 못하기 때문에 자원의 낭비를 초래하게 된다. 따라서 일반적으로 프로그램이 입출력을 수 행중인 경우 CPU를 다른 프로그램에게 이양해 CPU가 계속 쉬지 않고 일할 수 있도록 관리한다. 예를 들어 프로그램 A가 CPU를 할당받고 명 령을 수행하다가 입출력 요청을 하게 되면 입출력 작업이 완료될 때까 지 CPU의 낭비가 초래되므로 CPU를 프로그램 A에게서 선점해 다른 프로그램 B에게 할당하게 된다. 그러면 프로그램 B가 CPU를 할당받 아 명령을 수행하고，프로그램 A의 입출력이 완료될 때까지 A에게는 CPU를 다시 할당하지 않는다. 이는 입출력이 완료될 때까지 그  프로그램에 CPU를 할당하더라도 명령을 수행하지 못하기 때문인데，이것을 프로그램을 봉쇄 상태 (blocked s切te)로 전환시킨다고 말한다. 봉쇄 상 태의 프로그램에게는 CPU를 할당하지 않고，CPU를 할당하면 곧바로 작업을 수행할 수 있는 프로그램들에게만 CPU를 할당한다.
어떤 프로그램이 동기식 입출력을 수행중일 때 CPU를 다른 프로그 램에게 양도하지 않는다면 매 시점 시스템 내에서는 하나의 입출력 연 산만이 수행될 수 있다. 이 경우 동기화는 자동적으로 이루어질 수 있다. 그러나，앞서 설명한 것처럼 입출력이 수행중일 때 다른 프로그램 에게 CPU를 양도하게 되므로 다수의 입출력 연산이 동시에 요청되거 나 처리될 수 있다. 예를 들어 A라는프로그램이 디스크에 원래 1이던 파일의 내용을 3으로 바꾸는 입출력 연산을 요청했다고 하자. 그리고 입출력 연산을 수행중일 때 A에게서 CPU를 선점해 B에게 할당했다고 하자. 한편，프로그램 B가 CPU를 할당받고 수행중일 때，이 프로그램 역시 입출력 요청을 할 수 있다. 공교롭게도 프로그램 B가 요청한 입출 력 연산이 A가 접근하려는 곳과 동일한 파일의 내용을 1 증가시키는 연산이었다고 하자. 이 경우 매 시점 두 개 이상의 입출력 연산을 수행 할 수 있다면，컨트롤러는 A와 B의 순서를 바꾸어 수행할 가능성이 있 다. 즉 A가 입출력을 요청한 다음 B가 요청했는데，컨트롤러는 작업을 바꿔서 B의 요청을 먼저 처리할 수 있다. 그렇게 되면 해당 파일의 값 이 1 一＞ 3 로 변하는 것이 아니라 1 一＞ 2 3이 되어 의도하지 않은 결과를 초래하게 된다. 따라서，동기식 입출력에서는 입출력 요청의 동기화를 위해 장치별로 큐(queue)를 두어 요청한 순서대로 처리할 수 있도록 한다. 프로그램 A가 먼저 요청했으면 이를 먼저 큐에 넣고，그 후에 발생한 B의 요청을 A의 요청 뒤에 삽입하는 것이다. 디스크 차원 에서는 큐에 있는 순서대로 처리함으로써 동기화 문제를 해결한다.
지금까지 설명한 동기식 입출력을 간단히 요약해 보면 다음과 같다. 동기식 입출력을 요청한 프로그램은 입출력이 완료될 때까지 다음 명령을 수행할 수 없기 때문에 그동안 CPU가 낭비 된다. 또한，이 경우 다 른 프로그램에게 CPU를 양도하는 방법을 쓰지 않고，입출력 연산이 완료될 때까지 기다린다면，매 시점 하나의 입출력 연산만이 일어날 수 있다. 그러나 CPU의 효율적인 사佔을 위해 입출력이 수행되는 동안 다른 프로그램에게 CPU를 양도하면 동시에 다수의 입출력 연산이 일어 날 수 있다. A라는 프로그램이 입출력을 요청해서 수행중에 프로그램 B가 입출력 연산을 요청하면 또 다른 입출력 연산이 일어날 수 있기 때 문이다. 이와 같이 다수의 프로그램이 동시에 입출력 연산을 요청하는 경우 동기성 (synchronization)을 보장하기 위해 장치마다 큐를 두어 요 청된 순서대로 처리할 수 있도록 한다.
〈그림 3.3〉에서 보는 것과 같이 장치마다 큐 헤더가 존재하고 각 장 치별로 입출력 수행 순서를 지켜 주기 위한 큐를 관리하고 있다. 컨트 롤러는 이 순서에 따라 매 시점 하나씩 자신에게 주어진 입출력 작업을 처리하게 된다. CPU의 수행 속도에 비해 컨트롤러의 수행 속도나 장치 자체의 작업 수행 능력은 매우 떨어진다. 그렇기 때문에 입출력이 완 료될 때까지 CPU가 아무 일도 못하게 하는 것이 아니라，입출력과 관 련 없는 프로그램을 수행하도록 하고，요청된 입출력 연산이 완료되면 CPU에게 입출력이 완료되었음을 알려 주는 방식으로 진행된다. 연산 완료의 통보는 인터 럽트를 통해서 수행하며, 이 경우 운영 체제 커널은 인터 럽트 처리 루틴으로 가서 입출력 연산을 끝낸 프로그램이 CPU를 할당받을 수 있도록 그 프로그램의 상태를 봉쇄 상태로부터 해제시키 게 된다.
한편 비동기식 입출력은 입출력 연산을 요청한 후에 연산이 끝나기 를 기다리는 것이 아니라 CPU의 제어권을 입출력 연산을 호출한 그 프 로그램에게 곧바로 다시 부여하는 방식을 말한다. 어떤 프로그램이 데 이터를 디스크에서 읽어오라는 요청을 했을 때 보통은 읽어온 결과를 이용해서 다음 연산을 수행하지만 경우에 따라서는 그 데이터와 관련 없이 수행할 수 있는 일이 있을 수 있다. 비동기식 입출력에서는 그러 한 작업을 먼저 수행하고，읽어오는 데이터가 반드시 있어야 수행할 수 있는 일들은 입출력이 완료된 후에 수행하게 된다. 또한，입출력 요청 이 디스크에서 읽어오는 요청이 아니라 디스크에 쓰는 요청이라면 쓰 기 작업이 완료되기 전에도 다음 명령을 수행할 수 있으므로 비동기식 입출력이 사용될 수 있다.



〈그림 3.4〉는 동기식 입출력과 비동기식 입출력을 비교해 보여 주고 있다. 사용자가 I/O 요청을 하면 동기식 입출력에서는 먼저 운영 체제 의 커널로 CPU의 제어권이 넘어와서 입출력 처리와 관련된 커널의 코 드가 수행된다. 이 때，입출력을 호출한 프로세스의 상태를 봉쇄 상태 로 바꾸어 입출력이 완료될 때까지 CPU를 할당받지 못하도록 한다. 입 출력이 완료되면 I/O 컨트롤러가 CPU에게 인터 럽트를 발생시켜 입출 력이 완료되었음을 알려 준다. 그러면 이 프로세스의 봉쇄 상태를 해 제시켜 CPU를 할당받을 수 있는 권한이 다시 생기게 된다.
반면 비동기식 입출력에서는 CPU의 제어권이 입출력을 요청한 프로 세스에게 곧바로 다시 주어지게 되며，입출력 연산이 완료되는 것과 무 관하게 처리 가능한 작업부터 처리한다. 한편, 비동기식 입출력에서도 입출력 연산이 완료되면 동기식과 마찬가지로 인터럽트를 통해 이를 CPU에게 알려 주게 된다. 그러면 그 시점부터 읽어온 데이터를 필요로 하는 명령을 수행할 수 있게 된다.
이러한 과정을 구체적인 예를 통해 살펴보면 다음과 같다. 프로그램 A가 실행중에 디스크에서 어떤 데이터를 읽어오는 명령을 만나게 되 면 프로그램 A는 시스템 콜을 통해 CPU에게 일종의 소프트웨어 인터 럽트를 발생시킨다. 그러면 CPU는 지금까지 프로그램 A의 코드를 수 행하던 일을 멈추고 현재의 수행 상태를 저장한 후에，인터 럽트에 의해 처리해야 할 커널의 루틴으로 이동한다. 처리 루틴으로 이동하면 CPU 는 컨트롤러에게 입출력 연산을 요청하게 된다. 그러면 컨트롤러는 A 가 요청한 데이터를 디스크로부터 자신의 로컬 버퍼로 읽어오게 된다. 읽어오는 동안에 프로그램 A는 CPU를 선점당하게 된다. 또한，운영 체제는 프로그램 A가 입출력 연산을 요청했으므로 CPU를 할당해도 명령을 수행하지 못한다는 사실을 봉쇄 상태로 표시해 두게 된다. 그 리고 CPU를 다른 프로세스에게 할당해 계속 CPU가 일을 할 수 있도록 한다. 원하는 정보가 로컬 버퍼로 다 들어오면 컨트롤러는 CPU에게 입 출력이 완료되었다는 사실을 인터 럽트를 발생시켜 알리게 된다. 이 때 발생하는 인터럽트는 하드웨어 인터럽트에 해당한다. 프로그램 B를 수행중이던 CPU는 수행하던 지점 및 상태를 저장해 놓고 인터 럽트를 처리하게 된다. 인터 럽트 처리 루틴은 로컬 버퍼에 있는 A가 요청한 데 이터를 A의 메모리 영역으로 읽어오고，A의 봉쇄 상태를 해제시켜 이 제 A에게 CPU를 할당해도 됨을 표시한다. 그러면 A는 CPU를 기다리 는 줄에 다시 서게 된다. 그 후 원래 수행하던 프로그램 B의 지점으로 돌아가서 하던 업무를 계속 수행하게 된다. 프로그램 A는 CPU를 기다 리는 줄에서 기다리다가 자신의 차례가 되면 CPU를 할당받고 입출력 연산 이후의 작업을 수행하게 된다.
지금까지 동기식 입출력과 비동기식 입출력에 대해 설명했다. 일반 적으로는 위의 예에서 설명한 것처럼 입출력 요청을 운영 체제에게 하 게 되면 해당 프로그램의 입출력이 완료될 때까지 그 프로그램을 봉쇄 시키는 동기식 입출력을 사용한다. 이 때 운영 체제는 장치별로 입출 력 처리를 기다리는 프로세스를 줄 세워 관리함으로써 동기성을 보장 하게 되는 것이다.


<br/><br/>

## 6. DMA(Direct Memory Access)


원칙적으로 메모리는 CPU에 의해서만 접근 가능한 장치이다. 따라

서，주변 장치들이 메모리에 접근하기 위해서는 CPU에게 인터 럽트를 발생시켜 CPU가 일을 대행하는 식으로만 가능하다. 이전에 보았던 것 처럼 컨트롤러가 CPU에게 인터 럽트를 발생시키면 CPU는 컨트롤러의 로컬 버퍼와 메모리 사이에서 데이터를 옮겨  주는 일을 하게 된다. 한편, 모든 메모리 접근 연산이 CPU에 의해서만 이루어질 경우 주변 장 치가 메모리 접근을 원할 때마다 인터 럽트를 통해 CPU의 업무가 방해 를 받게 되어 CPU 사용의 효율성이 떨어지는 문제점이 발생하게 된다. 이러한 비효율성을 극복하기 위해 CPU 이외에 메모리 접근이 가능한 장치를 하나 더 두는 경우가 많은데，이와 같은 장치를 DMA(Direct Memory Access)라고 부른다. DMA는 일종의 컨트롤러로서，CPU가 주 변 장치들의 메모리 접근 요청에 의해 자주 인터 럽트당하는 것을 막아 주는 역할을 한다. DMA를 사용하게 되면 로컬 버퍼에서 메모리로 읽 어오는 작업을 CPU가 담당하는 것이 아니라，DMA가 대행함으로써 CPU는 원래 하던 작업을 멈추고 인터 럽트를 처리할 필요가 없어지는 것이다. 

이 때 DMA는 바이트(byte) 단위가 아니라 블록(block)이라는 큰 단위로 정보를 메모리로 읽어온 후에 cpu에게 인터럽트를 발생시켜서 해당 작업의 완료를 알려 주게 된다. 이러한 방식으로 cpu에 발생하는 인터럽트의 빈도를 줄여 cpu를 좀더 유용하게 사용하고 입출력 연산을 더욱 빠르게 수행할 수 있게 된다.


<br/><br/>

## 7. 저장 장치의 구조
<br/><p align = "center">
<img src = "img\20211104_071535064_09.jpg">
</p>

컴퓨터 시스템을 구성하는 저장 장치는 주 기억 장치와 보조 기억 장치로 나누어 볼 수 있다. 주 기억 장치는 보통 메모리라고 부르며 전원 이 나가면 저장되었던 내용이 모두 사라져 버리는 휘발성(volatile)의 RAM을 매체로 사용하는 경우가 대부분이다. 이에 비해 보조 기억 장치 는 전원이 나가도 저장된 내용을 기억할 수 있는 비휘발성(nonvolatile) 의 마그네틱 디스크를 흔히 사용한다. 이 밖에도 보조 기억 장치로는 플래시 메모리，CD，마그네틱 테이프 등이 사용되기도 한다.
보조 기 억 장치의 용도는 크게 두 가지로 구분된다. 그 첫째는 파일 시스템(file system)용이다. 전원이 나가도 유지해야 할 정보가 있으면 그것을 파일 형태로 보조 기억 장치에 저장하게 된다. 메모리는 휘발 성 매체이기 때문에 비휘발성 매체인 디스크를 파일 시스템용으로 혼 히 사용하는 것이다. 보조 기억 장치의 두 번째 용도는 메모리의 연장 공간인 스왑 영 역(swap area)용이다. 메모리는 크기가 한정되고，가격 이 상대적으로 비싼 데다가 용량이 적은 경우가 대부분이다. 그러므로 다수의 프로그램이 메모리에 올라가 동시에 수행되는 현대의 컴퓨터 환경에서는 메모리 공간이 부족할 경우가 흔히 발생하게 된다. 이 경 우 운영 체제는 프로그램 수행 에 당장 필요한 부분만 메모리에 올려 놓 고 그렇지 않은 부분은 디스크의 스왑 영역에 내려놓게 된다. 디스크 에 내려놓는 일을 스왑 아웃(swap out)시킨다고 말하며，스왑 아웃된 부분이 필요할 때에는 다시 메모리 영역으로 올리게 된다. 실행중인 프로그램의 내용을 내려놓는 스왑 영역으로는 하드 디스크가 가장 널 리 사용된다. 스왑 영역은 프로그램이 실행될 때 내용을 저장했다가 프로그램이 종료될 때 삭제하는 메모리의 연장 공간으로서의 역할을 담당하므로 파일 시스템처럼 비휘발성 용도로 사용되는 것과는 역할 이 구분된다.


보조 기억 장치 중 가장 대표적인 저장 매체인 하드 디스크는〈그림 3.5〉에서 보는 것과 같이 여러 개의 마그네틱 원판들이 있고, 암(arm) 이 이동하며 원판에 저장된 데이터를 읽고 쓰는 방식으로 동작하게 된 다. 디스크 원판의 표면은 트랙(track)으로 나뉘고，각 트랙은 섹터 (sector)로 나뉜다. 섹터 에 최소한의 단위 정보가 저장된다.



<br/><br/>

## 8. 저장 장치의 계층 구조
<br/><p align = "center">
<img src = "img\20211104_071535064_07.jpg">
</p>


컴퓨터 시스템을 구성하는 저장 장치는 빠른 저장 장치부터 느린 저 장 장치까지 단계적인 계층 구조로 이루어진다. 빠른 저장 장치는 단 위 공간당 가격이 높기 때문에 적은 용량을 사용하며，느린 저장 장치 는 가격 이 저 렴해 대용량을 사용하는 반면 접근 속도가 느리다는 약점 이 있다. 따라서，당장 필요한 정보는 빠른 저장 장치에 넣어 두어 수행 속도를 높이고 그렇지 않은 정보는 상대적으로 느린 저장 장치에 보관 하게 된다.〈그림 3.6〉에서 볼 수 있는 것처럼 저장 장치 계층은 최상 위의 CPU 내부에 존재하는 레지스터(register)부터 캐쉬 메모리(cache memory), 메인 메모리 등의 휘발성 저장 장치로 구성되는 부분이 상위 에 존재하며 이 부분에 저장되는 정보는 전원이 나가면 그 내용이 사라 지게 된다. 반면 메인 메모리보다 아랫 부분을 구성하는 저장 장치 계 충은 전원이 나가도 지워지지 않는 비휘발성 저장 장치이다.
상위 저장 장치 계층으로 갈수록 접근 속도가 월등히 빠르지만 용량 은 상대적으로 적다. 하지만，당장 필요한 정보만을 선별적으로 저장 하게 되면 마치 하위에 있는 큰 용량의 저장 장치를 가지고 있는 것과 비슷한 성능 효과를 낼 수 있다. 예를 들면 캐쉬 메모리는 레지스터와 메인 메모리 사이에 존재하며 가격적인 측면에서는 메인 메모리보다 비싸다. 그러나 여러 가지 캐슁 기법을 이용해 적은 용량의 캐쉬 메모 리를 사용해서도 메인 메모리와 같이 큰 용량을 가진 것처럼 효율적으로 동작하도록 관리할 수 있다. 이 때，캐슁 기법이란 캐쉬 메모리뿐 아 니라 상대적으로 용량이 적은 빠른 저장 장치의 성능 향상을 위한 총체 적 기법을 일컫는다. 캐슁 기법은 상대적으로 느린 저장 장치에 있는 내용 중에 당장 사용되거나 빈번히 사용될 정보를 빠른 저장 장치에 선 별적으로 저장해 두 저장 장치 사이의 속도를 완충시키는 기법을 의미 한다. 빠른 저장 장치에 빈번히 사용될 정보를 저장하면 필요한 정보 를 빠른 저장 장치에서 곧바로 찾을 수 있는 경우가 많아져 전체적인 성능이 향상된다. 이와 같은 캐슁 기법이 적은 용량으로도 효과를 거 둘 수 있는 것은 컴퓨터 내의 데이터나 프로그램을 구성하는 모든 부분 이 균일하게 참조되는 것이 아니라 일부분만이 집중적으로 참조되고 어떠한 부분은 거의 참조되지 않기 때문이다. 예를 들어 프로그램의 코드 중에는 많은 횟수 동안 반복되는 코드와，한번 수행되고 끝나는 부분이 있을 수 있다. 이 러한 경우 반복되는 코드를 빠른 저장 장치에 올려 놓으면 적은 저장 공간만으로도 전체 시스템의 평균적인 성능을 향상시킬 수 있다. 이러한 캐슁 기법을 컴퓨터 시스템 내의 다양한 저 장 장치 계층에서 활용함으로써 적은 용량의 상위 저장 장치만으로도 대부분의 경우 빠른 수행 속도의 성능을 얻어 낼 수 있게 된다.


<br/><br/>

## 9. 하드웨어의 보안
<br/><p align = "center">
<img src = "img\20211104_071535064_04.jpg">
</p>


우리가 흔히 사용하는 운영 체제는 여러 프로그램이 동시에 실행될 수 있는 다중 프로그래밍 (multi-programming) 환경에서 동작한다. 그 러므로 각 프로그램들이 다른 프로그램의 실행을 방해하거나 프로그램 간에 서로 충돌을 일으키는 문제를 막기 위해 하드웨어에 대한 각종 보안 기법이 필요하다. 하드웨어적인 보안을유지하기 위해서 운영 체 제는 기본적으로 두 가지 모드의 오퍼레이션(operation)을 지원한다. 커널 모드(kernel mode, system mode)와 사용자 모드(user mode)가 이에 해당한다. 어떤 프로그램이 이상한 명령을 수행시켜 다른프로그 램의 메모리 영역이나 파일 영역을 침범하는 경우가 발생할 수 있다. 따라서 중요한 정보에 접근해 위험한 상황을 초래할 수 있는 연산은 커 널 모드에서만 실행되도록 하여 일반 사용자 프로그램이 직접 위험한 명령을 수행할 수 없도록 하고 그렇지 않은 일반적 인 연산만 사용자 모 드에서 사용자 프로그램이 수행 가능하도록 통제하여 보안성을 확보 하게 된다.
커널 모드는 운영 체제가 CPU의 제어권을 가지고 운영 체제 코드를 실행하는 모드로서，이 모드에서는 모든 종류의 명령을 다 실행할 수 있다. 반면，사용자 모드에서는 일반 사용자 프로그램이 실행되며 제 한적인 명령만을 수행할 수 있다. 시스템에 중요한 영향을 미치는 연 산은 커널 모드에서만 실행 가능하도록 함으로써 하드웨어의 보안을 유지하는 것이다.
그러나 중요한 연산을 운영 체제만이 수행할 수 있도록 정의하더라 도 사용자 프로그램이 프로그램 내에서 그런 종류의 연산을 수행해 버 리면 제어가 아무런 소용이 없게 된다. 사용자 프로그램이 CPU를 가지 고 있는 동안에는 운영 체제가 CPU를 선점할 수 없으므로 사용자 프로 그램을 감시할 수 있는 방법이 없기 때문이다. 그러므로 이러한 상황을 방지하기 위해서는 하드웨어적인 지원이 필요하다. 컴퓨터 시스템은 CPU 내부에 모드 비트(mode bit)< 두어 사용자 프로그램을 감시하게 된다. 모드 비트가 0으로 세팅되어 있으면 커널 모드로서 모든 명령을 수행할 수 있고，모드 비트가 1로 세팅되어 있으면 사용자 모드로서 제 한된 명령만을 수행할 수 있다. CPU는 보안과 관련된 명령을 수행하기 전에는 항상 모드 비트를 조사해 모드 비트가 0으로 세팅된 경우에만 그 명령을 수행한다. 운영 체제가 CPU를 점유해 자신의 코드를 수행하 다가 사용자 프로그램에게 CPU의 제어권을 넘길 때 모드 비트를 1로 세팅해 넘기게 된다. 이러한 방식으로 사용자 프로그램은 보안과 관련 된 중요한 명령의 수행에 제약을 받게 되기 때문에 하드웨어를 보호할 수 있다. 사용자 프로그램이 수행되다가 하드웨어 접근 등 보안이 필요 한 중요한 명령을 수행해야 할 경우에는 시스템 콜을 통해 운영 체제에 게 서비스를 대신해 줄 것을 요청하게 된다. 그러면 CPU의 제어권은 다 시 운영 체제로 넘어가게 된다. 인터 럽트가 발생할 때에는 모드 비트가 자동적으로 0으로 세팅되어 운영 체제는 서비스에 필요한 모든 종류의 명령을 다 수행할 수 있다. 요청된 작업이 모두 끝난 후에는 모드 비트 를 다시 1로 만들어 사용자 프로그램에게 CPU를 넘겨 주게 되는 것이 다. 이와 같이 시스템의 보안과 관련된 명령들을 특권 명령이라 지칭하 며，특권 명령은 모드 비트가 0일 때에만 수행할 수 있게 된다. 즉，특권 명령은 커널 모드에서 운영 체제에 의해서만수행이 가능한 것이다. 각종 하드웨어 장치 에서 보안이 유지되는 방식 에 대해 자세히 알아 보도록 하겠다. 사용자 프로그램이 디스크에 저장되어 있는 파일을 자 유롭게 접근할 수 있다면 보안에 문제가 발생할 수 있다. 자신의 소유 가 아닌 다른 사람의 파일에 접근할 수 있기 때문이다. 그래서 모든 입 출력 명령은 특권 명령으로 규정해서 사용자 프로그램이 직접 입출력 을 하는 것을 차단한다. 그리고，입출력이 필요할 때에는 운영 체제에게 서비스를 요청하여 운영 체제가 입출력 명령을 대신 수행하게 된 다. 입출력은 특권 명령이기 때문에 모드 비트가 0일 때에만 수행할 수 있으며，사용자 프로그램이 입출력을 하고 싶으면 시스템 콜로 운영 체 제에 요청해야 한다. 그러면 운영 체제가 CPU를 할당받고 인터 럽트 벡 터의 특정 위치를 통해 해당 인터럽트 서비스 루틴으로 이동한다. 이 때 인터럽트 하드웨어에 의해 모드 비트가 0으로 세팅되어 운영 체제 는 입출력을 수행할 수 있게 된다. 한편，운영 체제는 입출력 요청이 올 바른 요청 인지 확인한 후 입출력을 실행하기 때문에 파일에 대한 보안 을 유지할 수 있다. 요청된 입출력이 완료되면 CPU의 제어권을 다시 사용자 프로그램에게 넘길 수 있게 되며，사용자 프로그램이 다시 CPU 를 할당받으면 시스템 콜 이후의 명령을 수행할 수 있게 된다.

<br/><br/>

## 10. 메모리 보안
<br/><p align = "center">
<img src = "img\20211104_071535064_03.jpg">
</p>
<br/><p align = "center">
<img src = "img\20211104_071535064_01.jpg">
</p>


디스크뿐 아니라 메모리의 경우에도 보안이 필요하다. 이는 여러 프 로그램이 메모리에 동시에 올라가서 실행되기 때문에 하나의 사용자 프로그램이 다른 사용자 프로그램이나 운영 체제가 위치한 메모리 영 역을 침범할 수 있기 때문이다. 예를 들어 하나의 사용자 프로그램이 C 언어의 포인터 등 메모리 주소 참조 연산을 잘못 사용해 다른 사용자 프로그램의 메모리 영역이나 운영 체제 커널이 위치한 영역을 침범할 수 있다. 적어도 인터럽트 벡터와 인터럽트 처리 루틴이 있는 곳은 각 별한 보안이 필요하다. 이는 인터 럽트 처 리 루틴을 사용자 프로그램이 접근 및 변경할 수 있을 경우 운영 체제만 수행 가능한 특권 명령을 보 안성이 침해되는 이상한 명령으로 변형할 수 있기 때문이다. 이러한 문제를 해결하기 위해 두 개의 레지스터를 사용해서 프로그램이 접근 하려는 메모리 부분이 합법적인지를 체크함으로써 메모리 보호가 이 루어진다. 이 때 사용되는 두 개의 레지스터는 기준 레지스터(base register)와 한계 레지스터(limit register)이다. 기준 레지스터는 어떤 프 로그램이 수행되는 동안 그 프로그램이 합법적으로 접근할 수 있는 메 모리 상의 가장 작은 주소를 보관하고 있고，한계 레지스터는 그 프로 그램이 기준 레지스터 값부터 접근할 수 있는 메모리의 범위를 보관하 고 있다. 즉 어떤 프로그램이 실제 메모리에 올라가 있는 부분의 시작 주소와 그 프로그램의 길이를 각각 기준 레지스터와 한계 레지스터에 보관해 메모리 접근 연산이 있을 때마다 하드웨어적으로 현재 접근하 려는 위치가 합법적 인 범위인지를 체크하게 된다. 사용자 프로그램은 기준 레지스터 에 있는 주소부터 기준 레지스터 + 한계 레지스터 값 사 이의 주소 영역만 접근이 가능하며 접근하려는 주소가 이 범위 안에 없 으면 불법적인 메모리 접근이므로 예외 상황이라는 일종의 소프트웨 어적인 인터 럽트가 발생하게 된다. 예외 상황은 운영 체제에게 소프트 웨어적인 인터 럽트를 발생시켜 CPU의 제어권을 해당 프로그램으로부터 운영 체제로 이양시키고 운영 체제는 예외 상황을 발생시킨 프로그 램을 강제로 종료시킨다. 단 여기에서 살펴본 기준 레지스터와 한계 레지스터를 통한 메모리 보호 기법은 하나의 프로그램이 메모리의 한 영역에 연속적으로 위치하는 경우에 대한 설명이다. 이 책의 후반부에 서 다룰 다양한 메모리 관리 기법에서는 하나의 프로그램이 메모리 여 러 영역에 나뉘어 위치하는 페이징(paging) 기법 등에 대해서도 다루 게 될 것이다. 이 경우 두 개의 레지스터뿐 아니라 다른 하드웨어의 지 원을 통해서 연속적이지 않은 공간에 프로그램이 위치하는 좀더 현실 적인 시스템에서의 메모리 보호에 대해서 살펴보게 될 것이다.
메모리 접근 연산은 사용자 프로그램이 CPU를 가지고 있는 동안에 도 수행할 수 있는 연산이므로 특권 명령은 아니다. 다만，사용자 프로 그램이 메모리를 접근하기 전에 하드웨어적으로 그 접근이 합법적인 지를 체크하여 메모리를 보호하게 된다. 이것이 운영 체제만이 수행할 수 있는 입출력 연산과 메모리 접근 연산과의 차이점이라고 할 수 있다. 사용자 모드인 경우에는 기준 레지스터와 한계 레지스터를 사용해 서 메모리를 보호하게 되고，커널 모드에서는 메모리 에 무제한으로 접 근이 가능하다. 메모리 접근 명령은 특권 명령이 아니지만，올바르지 않은 접근 시도로부터 메모리를 보호하기 위해서는 기준 레지스터와 한계 레지스터의 값을 세팅하는 연산은 특권 명령으로 규정해야 한다. 만약 프로그램이 자신의 기준 레지스터와 한계 레지스터의 값을 직접 변경할 수 있다면 메모리에 무제한 접근하는 것이 가능하기 때문이다. 그러므로 운영 체제가 두 개의 레지스터 값을 직접 세팅해 주고 사용자 프로그램은 값을 변경할 수 없게 한다.



<br/><br/>

## 11. CPU 보호

일반적으로 CPU는 컴퓨터 시스템 내에 하나밖에 존재하지 않기 때 문에 특정 프로그램이 CPU를 독점해 무한 반복문을 수행하는 등 부적 절한 방법으로 CPU의 제어권을 독점하고 있다면 다른 프로그램 및 운영 체제가 CPU의 제어권을 획득할 수 있는 방법 이 없게 된다. 이와 같이 CPU가 하나의 프로그램에 의해 독점되는 것을 막기 위해 운영 체제 는 타이머(timer)라는 하드웨어를 사용한다. 타이머는 정해진 시간이 지나면 인터럽트를 발생시켜 운영 체제에게 CPU의 제어권을 이양시 키는 역할을수행한다. 타이머에 의해 발생되는 인터럽트처리 루틴의 내용은 지금 CPU를 할당받고 수행중인 프로그램에게서 CPU를 선점 해 다른 프로그램에게 CPU를 이양하는 내용이다. 타이머는 일정한 시 간 단위로 세팅될 수 있으며 매 클럭 틱 때마다 1씩 감소한다. 타이머 가 0이 되는 순간에 인터 럽트가 발생하게 된다. 타이머는 시분할 시스 템(time sharing system)에서 현재 시간을 계산하기 위해서도 널리 사 용된다. 시분할 시스템이란 여러 프로그램이 CPU의 시간을 조금씩 나 누어 사용하는 시스템을 의미한다. 타이머의 값을 세팅하는 명령을 로 드타이머(loadtimer)라고하며, 이는특권 명령에 해당된다.


<br/><br/>

## 12. 시스템 콜을 이용한 입출력 수행
사용자 프로그램이 디스크의 파일에 데이터를 쓰거나 디스크의 파 일로부터 데이터를 읽어오는 행위，키보드로부터 입력을 받거나 수행 결과를 모니터에 출력하는 행위 등은 모두 특권 명령인 입출력 명령에 해당하므로 사용자 프로그램이 직접 수행할 수 없다. 이러한 입출력 명령은 운영 체제 코드에 구현되어 있으며，사용자 프로그램은 직접 입 출력을 수행하는 대신 운영 체제에게 시스템 콜이라는 서비스 대행 요 청을 하여 입출력을 수행하게 된다. 시스템 콜은 일종의 소프트웨어적인 인터 럽트로서 사용자 프로그램이 시스템 콜을 할 경우 트랩이 발생 해 CPU에 대한 제어권이 운영 체제로 넘어가게 된다. 그러면 운영 체 제는 해당 시스템 콜을 처리하기 위한 루틴으로 가서 정의된 명령을 수 행하게 된다. 시스템 콜이 디스크에 대한 입출력 요청이었으면 디스크 컨트롤러에게 입출력 요청을 수행하도록 명령하고，추후에 디스크 컨 트롤러가 입출력 수행을 마치면 CPU에게 인터럽트를 발생시켜 입출 력이 완료되었음을 알려 주어 해당 프로그램이 다시 CPU를 할당받을 수 있도록 한다.