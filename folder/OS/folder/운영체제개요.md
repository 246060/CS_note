# 운영 체제 개요

- [운영 체제 개요](#운영-체제-개요)
  - [1. 운영체제의 정의](#1-운영체제의-정의)
    - [커널(kernel)](#커널kernel)
  - [2. 운영체제의 기능](#2-운영체제의-기능)
  - [3. 운영 체제의 분류](#3-운영-체제의-분류)
    - [동시 작업 지원](#동시-작업-지원)
    - [다중 사용자 동시 지원](#다중-사용자-동시-지원)
    - [작업 처리 방식](#작업-처리-방식)
  - [4. 운영 체제의 자원 관리 기능](#4-운영-체제의-자원-관리-기능)
    - [CPU 관리 방법](#cpu-관리-방법)
    - [CPU 스케줄링](#cpu-스케줄링)
      - [선입 선출 기법](#선입-선출-기법)
      - [라운드 로빈](#라운드-로빈)
      - [우선순위](#우선순위)
    - [메모리 관리 방법](#메모리-관리-방법)
      - [고정 분할](#고정-분할)
      - [가변 분할](#가변-분할)
      - [가상 메모리](#가상-메모리)
    - [주변 장치 및 입출력 장치 관리 방법](#주변-장치-및-입출력-장치-관리-방법)
      - [인터럽트](#인터럽트)
      - [인터럽트 처리 루틴](#인터럽트-처리-루틴)
      - [컨트룰러](#컨트룰러)


<br/><br/><br/>

## 1. 운영체제의 정의
컴퓨터 하드웨어 바로 윗단에 설치된 소프트웨어

- 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층
- 각종 소프트웨어들은 운영체제 위에서 수행된다.
- 컴퓨터의 전원을 켜면 운영 체제는 이와 동시에 수행된다. 

### 커널(kernel)
- 운영체제 중 항상 필요한 부분만을 전원이 켜짐과 동시에 메모리에 올려놓고 그렇지 않은 부분은 필요할 때 메모리로 올려서 사용하게 된다. 이때, 메모리에 상주하는 운영체제의 부분을 커널이라고 한다. 
- 커널은 좁은 의미의 운영체제이며, 운영체제 코드 중에서도 핵심적인 부분이다.


<br/><br/><br/>

## 2. 운영체제의 기능
운영체제의 역할은 하드웨어에 대한 역할과 사용자에 대한 역할로 크게 나누어 볼 수 있다.

- (핵심기능) 컴퓨터 시스템 내의 자원을 효율적으로 관리
  - 자원 관리자
  - 자원이란 하드웨어 자원 뿐만 아니라 소프트웨어를 통칭
- 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공
  - 하드웨어를 직접 다루는 복잡한 부분은 운영 체제가 대행해 주고, 각 사용자 및 프로그램은 그에 대한 자세한 내용을 알지 못해도 프로그램을 수행할 수 있도록 해주는 기능
- 사용자 및 프로그램들 간에 자원이 형평성 있게 분배되도록 하는 균형자 역할
- 보안 및 보호 기능을 수행




<br/><br/><br/>

## 3. 운영 체제의 분류
여러 기준에 따라 분류가 된다.

### 동시 작업 지원

- 단일 작업용 운영체제
- 다중 작업용 운영체제
  - 시분할 시스템(time sharing system)
    - cpu의 작업 시간을 여러 프로그램들이 조금씩 나누어 사용하는 시스템
  - 다중 프로그래밍 시스템(multi-programming system)
    - 메모리 공간을 분할해 여러 프로그램들을 동시에 메모리에 올려놓고 처리하는 시스템
  - 대화형 시스템
    - 입력 결과를 곧바로 알려주는 시스템
  - 다중처리기 시스템(multi-processor system)
    - 하나의 컴퓨터안에 CPU가 여러 개 인 경우를 뜻함
  
### 다중 사용자 동시 지원

- 단일 사용자용 운영체제
  - 한 번에 하나의 작업만 수행할 수 있는 경우
  - 혼자 사용하지만 다중 작업이 가능한 경우
- 다중 사용자용 운영체제


### 작업 처리 방식
- 일괄 처리(batch processing) 방식 운영체제
  - 작업 요청의 일정량을 모아서 한꺼번에 처리하는 방식
  - 작업이 완전히 종료된 후에 결과 확인 가능
  - 응답 시간이 길다
- 시분할(time sharing) 방식 운영체제
  - 여러 작업을 수행 할때 컴퓨터의 처리능력을 일정한 시간 단위로 분할해 사용하는 방식
  - 사용자들의 작업을 짧은 시간 단위씩 번갈아 가며 처리
    - 응답 결과를 곧바로 알 수 있음 -> 대화형 시스템
- 실시간(real time) 방식 운영체제
  - 정해진 시간안에 어떠한 일이 반드시 종료됨이 보장되어야 하는 시스템
  - 시간 제약의 중요성에 따라 세분화
    - 경성 실시간 시스템(hard realtime system)
      - 시간을 지키지 못할 경우 위험한 결과 초래
    - 연성 실시간 시스템(soft realtime system)
      - 시간을 지키지 못할 겨우 위험한 결과는 초래하지 않음
  


> 소프트웨어의 이식성
> 소프트웨어를 다른 기종의 기계로 옮기는데 소요되는 노력이 어떤가를 나타내는 지표


<br/><br/><br/>

## 4. 운영 체제의 자원 관리 기능
운영체제의 자원 관리 기능을 간단히 살펴보기

<br/><p align = "center">
<img src = "https://images.velog.io/images/jehjong/post/9fe95e2d-c007-4bc8-84f9-9ed4dc1cbe4f/image.png" style="width:700px;">
</p>

### CPU 관리 방법

일반적인 컴퓨터에는 CPU가 하나밖에 없지만 프로세스는 여러 개가 동시에 실행된다. 그러므로 매 시점 어떠한 프로세스에게 CPU를 할당해 작업을 처리할 것 인지를 결정하는 일이 필요하다. 이러한 일을 CPU 스케줄링(CPU scheduling)이라고 한다. 


### CPU 스케줄링

CPU 스케줄링의 목표는 CPU를 가장 효율적으로 사용하면서도, 특정 프로세스가 불이익을 당하지 않도록 하는 것이다. 

대표적인 CPU 스케줄링 기법으로 선입선출(FCFS: First Come First Served), 라운드 로빈(Round Robin), 우선순위(priority) 기법이 있다.


#### 선입 선출 기법

먼저 도착한 프로세스를 먼저 처리해 주는 방식을 말한다. 이 방식에서는 CPU를 필요로 하는 프로세스가 여럿 있을 때 먼저 CPU를 요청한 프로세스가 원하는 작업을 완료할 때까지 다른 프로세스들이 CPU를 사용하지 못하게 된다. 이 방식을 사용할 경우, CPU 자체의 효율적인 사용 측면에서는 문제가 없지만 전체 시스템 입장에서는 비효율적인 결과를 초래할 가능성이 있다. 장시간 CPU를 사용해야 하는 프로세스가 먼저 도착하고, 짧은 시간 동안 CPU를 사용하면 작업을 완료할 수 있는 프로세스들이 나중에 도착한 경우를 생각해 보자. 이러한 경우 짧은 수행 시간을 가진 프로세스들은 선행 프로세스가 작업을 마칠 때까지 장시간 기다려야 한다. 이러한 선입선출 기법의 단점을 보완하고자 고안된 기법이 라운드로빈 기법이다.


#### 라운드 로빈

<br/><p align = "center">
<img src = "https://images.velog.io/images/jehjong/post/82302f58-5f05-4a2b-9a2e-36965d3e9554/image.png" style="width:700px;">
</p>

CPU를 한 번 할당받아 사용할 수 있는 시간을 일정한 고정된 시간으로 제한한다. 그래서 긴 작업을 요하는 프로세스가 CPU를 할당받더라도 정해진 시간이 지나면 CPU를 내어놓고 CPU의 서비스를 기다리는 줄의 제일 뒤에 가서 기다려야 한다. 그러므로 라운드 로빈 스케줄링에서는 적어도 긴 작업을 수행하는 프로세스 때문에 짧은 작업을 가진 프로세스들이 무작정 오래 기다려야 하는 상황은 막을 수 있다. 그렇다면 1회 사용할 수 있는 할당 시간을 얼마로 할 것인가? 일반적으로 1회 할당 시간은 수 밀리 세컨드(ms) 정도의 단위를 사용한다. 그러면 100명의 사용자가 동시에 접속할 때에도 1초 이하의 응답 시간을 보장받을 수 있게 된다.


#### 우선순위

수행 대기중인 프로세스들에게 우선순위를 부여하고 우선순위가 높은 프로세스에게 CPU를 먼저 할당하게 된다. 시스템 내의 프로세스 중에는 상대적으로 더 중요한 프로세스가 있을 수 있으므로 그런 프로세스에게 우선순위를 높게 하여 CPU를 먼저 획득할 수 있도록 한다는 점이 우선순위 스케줄링의 철학이라 할 수 있다. 또한 지나치게 오래 기다리는 프로세스가 발생하지 않도록 기다린 시간이 늘어날수록 우선순위를 점차 높여 주는 방안도 우선순위 스케줄링에 활용될 수 있다.



### 메모리 관리 방법 

메모리는 CPU가 직접 접근할 수 있는 컴퓨터 내부의 기억 장치이다. 한정된 메모리 공간에 여러 프로그램을 수용하려면 메모리에 대한 효율적인 관리 메커니즘이 필요하다. 

메모리 관리를 위해 운영 체제는 메모리의 어느 부분이 어떤 프로그램에 의해 사용되고 있는지를 유지하게 되는데 이러한 정보는 주소(address)를 통해 관리된다. 운영 체제는 프로그램에게 메모리가 필요할 때 할당하고, 더 이상 필요하지 않게 될 때 회수한다. 또한 운영 체제는 각 프로세스가 자신의 메모리 영역만을 접근할 수 있도록 관리해야 한다.

메모리를 관리하는 방식에는 고정 분할(fixed partition) 방식, 가변 분할(variable partition) 방식, 가상 메모리 (virtual memory) 방식이 있다. 


#### 고정 분할

<br/><p align = "center">
<img src = "https://images.velog.io/images/jehjong/post/22d7ed0d-954e-4b39-9fd9-3c2d1a583de1/image.png" style="width:400px;">
</p>

물리적 메모리를 몇 개의 영구적인 분할로 나눈다. 나뉜 각각의 분할에는 하나의 프로그램이 적재된다. 고정 분 할 방식은 융통성이 없는 단점이 있다. 이는 동시에 메모리에 적재되는 최대 프로그램의 수가 분할 개수로 한정되기 때문이다. 그뿐만 아니라 분할의 크기보다 큰 프로그램은 적재가 불가능하게 된다. 메모리의 효율적인 사용 측면에서도 바람직하지 않다. 분할이 고정적이기 때문에 분할의 크기보다 작은 프로그램이 적재되는 경우 남는 영역이 발생하게 된다. 이것을 내부 조각(internal fragmentation)이라고 하는데. 내부 조각은 분할 영역에 올라온 프로그램에 의해서도 사용되지 않고 다른 프로세스에게도 할당될 수 없으므로 비효율적으로 낭비되는 공간이라 할 수 있다.




#### 가변 분할
매 시점 프로그램의 크기에 맞게 메모리를 분할해서 사용하는 방식을 말한다. 따라서 분할의 크기 때문에 큰 프로그램의 실행이 제한되는 문제는 발생하지 않는다. 그러나 물리적 메모리 크기보다 더 큰 프로그램의 실행은 여전히 불가능하다. 가변 분할 방식에서는 분할의 크기, 개수가 동적으로 변하므로 기술적 관리 기법이 필요하다. 가면 분할 방식을 사용하게 되면 고정 분할 방식에서 발생 하는 내부 조각은 발생하지 않지만 외부 조각(external fragmentation) 이 발생할 수 있다. 

외부 조각이란 프로그램에게 할당되지 않은 메모리 영역이지만 그 크기가 작아 프로그램을 올리지 못하는 메모리 영역을 말한다. 

외부 조각이 발생하는 경우를 예를 통해 살펴보도록 하겠다. 크기가 100인 프로그램 A가 실행되어 메모리에 100만큼의 영역을 할당받았다. 프로그램 A가 실행되는 도중에 크기가 50인 프로그램 B가 실행되어 A의 영역 바로 다음부터 메모리 공간 50을 할당받아 실행되고 있다. 이 때 A의 작업이 완료되어 A의 영역에 크기 80인 프로그램 C가 적재되었다. A의 크기는 100인데 80의 크기를 가진 프로그램 C가 이전의 A영역을 사용하고 있기 때문에 20만큼의 빈 공간이 생기게 된다. 이제 크기가 40인 프로그램 D가 실행된다고 하자. 그러면, 크기가 20인 공간이 비어 있지만 프로그램 D가 실행되기에는 충분하지 못한 공간이기 때문에 프로그램 D는 빈 공간 20을 사용하지 못한다. 이러한 크기 20의 공간을 외부 조각이라고 하며, 이 공간은 현재 비어 있는 공간이지만 그 크기가 작아 아직까지 프로세스에게 할당되지 못한 공간을 의미한다. 외부 조각 역시 낭비된 메모리 자원이라고 할 수 있다.

<br/><p align = "center">
<img src = "https://images.velog.io/images/jehjong/post/f3bcff3c-fb87-4366-9df8-e31a4e364c1d/image.png" style="width:400px;">
</p>


#### 가상 메모리
최근의 거의 모든 컴퓨터 시스템에서 사용하는 메모리 관리 기법이다. 가상 메모리 기법에서는 물리적 메모리보다 더 큰 프로그램이 실행되는 것을 지원한다. 이 때, **실행될 수 있는 프로그램의 크기는 가상 메모리 크기에 의해 결정된다.** 좀더 자세히 말하면, 모든 프로그램은 물리적 메모리와는 독립적으로 주소가 0부터 시작하는 자신만의 가상 메모리를 갖게 된다. 운영 체제는 가상 메모리의 주소를 물리적 메모리 주소로 매핑하는 기술을 이용해 주소를 변환시킨 후 프로그램을 물리적 메모리에 올리게 된다. 가상 메모리 기법에서는 물리적 메모리의 크기와 상관 없이 사용할 수 있는 메모리의 크기를 충분히 크다고 가정하고 프로그래밍을 할 수 있다. 그러므로 물리적 메모리의 크기가 4M byte라 하더라도 20M byte의 프로그램을 실행할 수 있다. 

이것을 가능하게 하는 원리는 다음과 같다. 프로그램의 전체 크기가 20M byte일지라도 전체가 항상 동시에 사용되는 것은 아니다. 그 러므로 현재 사용되고 있는 부분만 메모리에 올리고, 나머지는 하드 디스크(hard disk)와 같은 보조 기억 장치에 저장해 두었다가 필요할 때 적재하는 방식을 취한다. 이 때 사용되는 보조 기억 장치의 영역을 우리는 스왑 영역(swap area)이라고 부른다. 프로그램을 구성하는 주소 공간은 페이지라는 동일한 크기의 작은 단위로 나뉘어 물리적 메모리와 스왑 영역에 일부분씩 저장된다. 이렇게 동일한 단위로 메모리를 나누는 기법을 페이징(paging) 기법이라고 한다. 


### 주변 장치 및 입출력 장치 관리 방법

#### 인터럽트
주변 장치 및 입출력 장치는 CPU나 메모리와 달리 인터럽트(interrupt)라는 메커니즘을 통해 관리하게 된다. 주변 장치들은 cpu의 서비스가 필요한 경우에 신호를 발생시켜 서비스를 요청하게 되는데, 이때 발생시키는 신호를 인터럽트라고 한다. 

cpu는 평소에 cpu 스케줄링에 따라 자신에게 주어진 작업을 수행하고 있다가 인터럽트가 발생하면 하던 일을 잠시 멈추고 인터럽트에 의한 요청 서비스를 수행하게 된다. 

인터럽트를 발생시키는 경우의 대표적인 예는 다음과 같다. 사용자가 키보드에 글자를 입력하면 키보드는 cpu에게 인터럽트를 발생시켜 사용자로부터 입력이 들어왔음을 알리게 된다. 그러면 cpu는 하던 일을 멈추고 인터럽트로 인해 처리해야 할 작업을 수행하게 된다.

키보드에 의해 인터럽트가 발생한 경우라면 사용자의 입력 데이터를 해당 프로그램에게 전달하는 절차를 수행하게 된다. 인터럽트 서비스를 완료한 후에는 원래 하던 일을 계속 수행하게 된다. 운영 체제는 인터럽를 처리한 후 원래 수행하던 작업으로 돌아오기 위해 언터럽트 처리 직전에 수행중이던 작업의 상태를 저장해 둔다.


#### 인터럽트 처리 루틴
인터럽는 요청하는 장치와 발생 상황에 따라 다양한 종류가 있기 때문에 운영체제는 인터럽트 종류마다 서로 다른 인터럽트 처리 루틴을 가지고 있다. 인터럽트 처리 루틴이란 인터럽트가 발생했을 때 해주어야 할 작업을 정의한 프로그램 코드를 말한다. 이것은 운영체제 커널 내에 존재하는 코드로 CPU 스케줄링, 메모리 관리 루틴 등 다양한 기능을 위한 커널 코드 중 일부분이라 할 수 있다. 인터럽트가 발생하면 운영체제는 해당하는 인터럽트 처리 루틴을 찾아 정의된 코드에 따라 일을 수행하게 된다.

#### 컨트룰러
주변 장치들은 각 장치마다 그 장치에서 일어나는 작업 관리를 위한 일종의 작은 CPU를  가지고 있다. 이를 컨트롤러라 한다.

컨트롤러는 해당 장치에 대한 업무를 처리하고 이를 메인 CPU에 인터럽를 발생시켜 보고하는 역할을 한다. 

예를 들어 키보드에 사용자로부터 입력이 들어오면 키보드 컨트롤러가 인터럽트를 발생시켜 CPU에게 그 사실을 알려 주게 되는 것이다. 그러면 CPU는 현재 수행중이던 작업의 상태를 저장하고 인터럽트 요청을 처리하기 위해 운영체제 내에 정의된 키보드 인터럽트 처리 루틴을 찾아가게 된다. 키보드 인터럽트 처리 루틴은 키보드로부터 입력받은 내용을 메모리의 특정 부분 에 저장해 해당 프로그램에게 키보드 입력이 들어왔음을 알리면서 인터럽트 처리를 완료한다. 인터럽트 처리가 끝나면 인터럽트가 발생하기 직전 상태를 복구시켜 중단되었던 작업을 재개한다. 주변 장치들은 이와 같이 인터럽트를 통해서 CPU의 서비스를 받을 수 있다.

